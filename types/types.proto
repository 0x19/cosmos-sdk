syntax = "proto3";
package cosmos_sdk.v1;

import "third_party/proto/gogoproto/gogo.proto";
import "third_party/proto/tendermint/abci/types/types.proto";
import "google/protobuf/any.proto";

option go_package                       = "github.com/cosmos/cosmos-sdk/types";
option (gogoproto.goproto_stringer_all) = false;
option (gogoproto.stringer_all)         = false;

// Coin defines a token with a denomination and an amount.
//
// NOTE: The amount field is an Int which implements the custom method
// signatures required by gogoproto.
message Coin {
  option (gogoproto.equal) = true;

  string denom  = 1;
  string amount = 2 [(gogoproto.customtype) = "Int", (gogoproto.nullable) = false];
}

// DecCoin defines a token with a denomination and a decimal amount.
//
// NOTE: The amount field is an Dec which implements the custom method
// signatures required by gogoproto.
message DecCoin {
  option (gogoproto.equal) = true;

  string denom  = 1;
  string amount = 2 [(gogoproto.customtype) = "Dec", (gogoproto.nullable) = false];
}

// IntProto defines a Protobuf wrapper around an Int object.
message IntProto {
  string int = 1 [(gogoproto.customtype) = "Int", (gogoproto.nullable) = false];
}

// DecProto defines a Protobuf wrapper around a Dec object.
message DecProto {
  string dec = 1 [(gogoproto.customtype) = "Dec", (gogoproto.nullable) = false];
}

// ValAddresses defines a repeated set of validator addresses.
message ValAddresses {
  option (gogoproto.stringer) = true;

  repeated bytes addresses = 1 [(gogoproto.casttype) = "ValAddress"];
}

// GasInfo defines tx execution gas context.
message GasInfo {
  // GasWanted is the maximum units of work we allow this tx to perform.
  uint64 gas_wanted = 1 [(gogoproto.moretags) = "yaml:\"gas_wanted\""];

  // GasUsed is the amount of gas actually consumed.
  uint64 gas_used = 2 [(gogoproto.moretags) = "yaml:\"gas_used\""];
}

// Result is the union of ResponseFormat and ResponseCheckTx.
message Result {
  option (gogoproto.goproto_getters) = false;

  // Data is any data returned from message or handler execution. It MUST be length
  // prefixed in order to separate data from multiple message executions.
  bytes data = 1;

  // Log contains the log information from message or handler execution.
  string log = 2;

  // Events contains a slice of Event objects that were emitted during message or
  // handler execution.
  repeated tendermint.abci.types.Event events = 3 [(gogoproto.nullable) = false];
}

// SimulationResponse defines the response generated when a transaction is
// successfully simulated.
message SimulationResponse {
  GasInfo gas_info = 1 [(gogoproto.embed) = true, (gogoproto.nullable) = false];
  Result  result   = 2;
}

message Tx {
  option (gogoproto.stringer) = true;

  TxBody body = 1;
  AuthInfo auth_info = 2;
  repeated bytes signatures = 3;
}

message SignDoc {
  option (gogoproto.stringer) = true;

  TxBody body = 1;
  AuthInfo auth_info = 2;
  string chain_id = 3;
  uint64 account_number = 4;
  // account_sequence starts at 1 rather than 0 to avoid the case where
  // the default 0 value must be omitted in protobuf serialization
  uint64 account_sequence = 5;
}

message TxBody {
  option (gogoproto.stringer) = true;

  repeated google.protobuf.Any messages = 1;
  string memo = 2;
  int64 timeout_height = 3;
  repeated google.protobuf.Any extension_options = 1023;
}

message AuthInfo {
  option (gogoproto.stringer) = true;

  repeated SignerInfo signer_infos = 1;
  // The first signer is the primary signer and the one which pays the fee
  Fee fee = 2;
}

message SignerInfo {
  option (gogoproto.stringer) = true;

  // PublicKey key is optional for accounts that already exist in state
  google.protobuf.Any public_key = 1;
  // ModeInfo describes the signing mode of the signer and is a nested
  // structure to support nested multisig pubkey's
  ModeInfo mode_info = 2;
}

message ModeInfo {
  option (gogoproto.stringer) = true;

  oneof sum {
    Single single = 1;
    Multi multi = 2;
  }

  // Single is the mode info for a single signer. It is structured as a message
  // to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the future
  message Single {
    option (gogoproto.stringer) = true;

    SignMode mode = 1;
  }

  // Multi is the mode info for a multisig public key
  message Multi {
    option (gogoproto.stringer) = true;

    // bitarray specifies which keys within the multisig are signing
    CompactBitArray bitarray = 1;
    // mode_infos is the corresponding modes of the signers of the multisig
    // which could include nested multisig public keys
    repeated ModeInfo mode_infos = 2;
  }
}

enum SignMode {
  SIGN_MODE_UNSPECIFIED = 0;

  SIGN_MODE_DIRECT = 1;

  SIGN_MODE_TEXTUAL = 2;

  SIGN_MODE_LEGACY_AMINO_JSON = 127;
}

// Fee includes the amount of coins paid in fees and the maximum
// gas to be used by the transaction. The ratio yields an effective "gasprice",
// which must be above some miminum to be accepted into the mempool.
message Fee {
  option (gogoproto.goproto_getters) = false;
  option (gogoproto.equal)           = true;
  option (gogoproto.stringer) = true;

  repeated Coin amount = 1
    [(gogoproto.nullable) = false, (gogoproto.castrepeated) = "Coins"];
  uint64 gas_limit = 2;
}

// CompactBitArray is an implementation of a space efficient bit array.
// This is used to ensure that the encoded data takes up a minimal amount of
// space after proto encoding.
// This is not thread safe, and is not intended for concurrent usage.
message CompactBitArray {
//  option (gogoproto.sizer)            = false;
//  option (gogoproto.goproto_stringer) = false;
  option (gogoproto.stringer) = true;

  uint32 extra_bits_stored = 1;
  bytes  elems             = 2;
}
