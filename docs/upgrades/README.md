# Update to Cosmos-SDK v0.40

The following document describes the changes, and an approach to update the chain to use Cosmos-SDK v0.40 
aka stargate release.

## Contents
- [Updating a module to use Cosmos-SDK v0.40](#updating-a-module-to-use-cosmos-sdk-v040)
- [Updating a cosmos-sdk chain to use SDK v0.40](#updating-a-cosmos-sdk-chain-to-use-sdk-v040)
- [Upgrading a live chain to v0.40](#upgrading-a-live-chain-to-v040)

## Updating a module to use Cosmos-SDK v0.40
This section covers the changes in modules from `v0.39.x` to `v0.40`.
### State
- `internal` package is removed and `types`, `keeper` are moved to module level
- `alias` usage is removed [#6311](https://github.com/cosmos/cosmos-sdk/issues/6311)
#### types/codec.go
- `codec.New()` is changed to `codec.NewLegacyAmino()`.
- Added `RegisterInterfaces` method in which we add `RegisterImplementations` and `RegisterInterfaces` based on msgs and interfaces in module.

    ```go
    func RegisterInterfaces(registry types.InterfaceRegistry) {
        registry.RegisterImplementations((*sdk.Msg)(nil),
            &MsgSend{},
            &MsgMultiSend{},
        )

        registry.RegisterInterface(
            "cosmos.bank.v1beta1.SupplyI",
            (*exported.SupplyI)(nil),
            &Supply{},
        )
    }
    ```
- `init()` changed from:
    ```go
    func init() {
	    RegisterCodec(cdc)
    }
    ```
    to:
    ```go
    func init() {
	    RegisterLegacyAminoCodec(amino)
	    cryptocodec.RegisterCrypto(amino)
    }
    ```
#### Msgs
SDK now leverages protobuf service definitions for defining Msgs which will give us significant developer UX 
improvements in terms of the code that is generated and the fact that return types will now be well defined.
`sdk.Msg`'s are now replaced by protobuf services. Now every sdk.Msg is defined as a protobuf service method.
Example: 
```proto
package cosmos.bank;

service Msg {
  rpc Send(MsgSend) returns (MsgSendResponse);
}
```
```proto
message MsgSend {
  string   from_address                    = 1 [(gogoproto.moretags) = "yaml:\"from_address\""];
  string   to_address                      = 2 [(gogoproto.moretags) = "yaml:\"to_address\""];
  repeated cosmos.base.v1beta1.Coin amount = 3
      [(gogoproto.nullable) = false, (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
}

message MsgSendResponse { }
```
We use protobuf service definitions for defining Msgs as well as the code generated by them as a replacement for Msg handlers.

*Encoding:*
Currently, we are encoding Msgs as Any in Txs which involves packing the binary-encoded Msg with its type URL.

The type URL for MsgSend based on the proto3 spec is /cosmos.bank.MsgSubmitProposal.

The fully-qualified name for the SubmitProposal service method above (also based on the proto3 and gRPC specs) is 
/cosmos.bank.Msg/Send which varies by a single / character. The generated .pb.go files for protobuf services 
include names of this form and any compliant protobuf/gRPC code generator will generate the same name.
In order to encode service methods in transactions, we encode them as Anys in the same TxBody.messages field as 
other Msgs. We simply set Any.type_url to the full-qualified method name (ex. /cosmos.bank.Msg/Send) and 
set Any.value to the protobuf encoding of the request message (MsgSend in this case).

*Decoding:*
When decoding, TxBody.UnpackInterfaces will need a special case to detect if Any type URLs match the service method format (ex. /cosmos.gov.Msg/SubmitProposal) by checking for two / characters. Messages that are method names plus request parameters instead of a normal Any messages will get unpacked into the ServiceMsg struct:

type ServiceMsg struct {
  // MethodName is the fully-qualified service name
  MethodName string
  // Request is the request payload
  Request MsgRequest
}

#### Keeper
The `Keeper` constructor now takes a `codec.Marshaler` instead of a concrete Amino codec. This exact type provided is 
specified by `ModuleCdc`.

#### module.go
* `type AppModuleBasic struct{}` is  updated to:

    ```go
    type AppModuleBasic struct {
        cdc codec.Marshaler
    }
    ```
* `RegisterCodec(cdc *codec.Codec)` method is changed to `RegisterLegacyAminoCodec(cdc *codec.LegacyAmino)`
* Added `RegisterInterfaces` method which implements `AppModuleBasic` which takes one parameter of type 
`"github.com/cosmos/cosmos-sdk/codec/types".InterfaceRegistry`. This method is used for registering interface types of module.
    ```go
    func (AppModuleBasic) RegisterInterfaces(registry cdctypes.InterfaceRegistry) {
        // register all interfaces in module.
	    types.RegisterInterfaces(registry) //module's types/codec.go
    }
    ````
* `DefaultGenesis()` takes codec input now
    ```go
    func (AppModuleBasic) DefaultGenesis(cdc codec.JSONMarshaler) json.RawMessage {}
    ```
* `ValidateGenesis` now requires `Marshaler`, `TxEncodingConfig`, `json.RawMessage` as input.
    ```go
    func (AppModuleBasic) ValidateGenesis(cdc codec.JSONMarshaler, config client.TxEncodingConfig, bz json.RawMessage) error {}
    ```
* `GetQueryCmd(cdc *codec.Codec)`,`GetTxCmd(cdc *codec.Codec)` is changed to `GetQueryCmd()`,`GetTxCmd()` respectively.
* Return type of `Route()` method which implements `AppModule` is changed from `string` to `"github.com/cosmos/cosmos-sdk/types".Route`. We will return a NewRoute which includes `RouterKey` and `NewHandler` as params.
    ```go
    func (am AppModule) Route() sdk.Route {
        return sdk.NewRoute(types.RouterKey, handler.NewHandler(am.keeper))
    }
    ```
* `QuerierHandler` is renamed to `LegacyQuerierHandler`.
  ```go
    func (am AppModule) LegacyQuerierHandler(legacyQuerierCdc *codec.LegacyAmino) sdk.Querier {}
  ```

* `RegisterServices` is added newly and it registers module's `MsgServer` and gRPC's `QueryServer`.
  ```go
  func (am AppModule) RegisterServices(cfg module.Configurator) {
      types.RegisterMsgServer(cfg.MsgServer(), keeper.NewMsgServerImpl(am.keeper))
      types.RegisterQueryServer(cfg.QueryServer(), am.keeper)
  }
  ```
* `RegisterGRPCGatewayRoutes` is added newly which is for registering module's gRPC gateway routes with API Server.`RegisterQueryHandlerClient` is auto generated by proto code generator.
    ```go
    // RegisterGRPCGatewayRoutes registers the gRPC Gateway routes for the bank module.
    func (AppModuleBasic) RegisterGRPCGatewayRoutes(clientCtx client.Context, mux *runtime.ServeMux) {
        types.RegisterQueryHandlerClient(context.Background(), mux, types.NewQueryClient(clientCtx))
    }
    ```
* `InitGenesis` and `ExportGenesis` require explicit codec input.
    ```go
    func (am AppModule) InitGenesis(ctx sdk.Context, cdc codec.JSONMarshaler, data json.RawMessage) []abci.ValidatorUpdate {}
    func (am AppModule) ExportGenesis(ctx sdk.Context, cdc codec.JSONMarshaler) json.RawMessage {}
    ```
### Querier
Stargate comes with new API service, gRPC. Module keeper implements the gRPC's `QueryServer` interface. 
Every module now has a `keeper/grpc_query.go` which contains the querier implementations. All the module query services
are defined in module's `query.proto` file. Here's an example for defining the query service:

/*cosmos/bank/v1beta1/query.proto*/
```go
// Query defines the gRPC querier service.
service Query {
    // AllBalances queries the balance of all coins for a single account.
    rpc AllBalances(QueryAllBalancesRequest) returns (QueryAllBalancesResponse) {
        option (google.api.http).get = "/cosmos/bank/v1beta1/balances/{address}";
    }
  ...
}

// QueryAllBalancesRequest is the request type for the Query/AllBalances RPC method.
message QueryAllBalancesRequest {
  option (gogoproto.equal)           = false;
  option (gogoproto.goproto_getters) = false;

  // address is the address to query balances for.
  string address = 1;

  // pagination defines an optional pagination for the request.
  cosmos.base.query.v1beta1.PageRequest pagination = 2;
}

// QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
// method.
message QueryAllBalancesResponse {
  // balances is the balances of all the coins.
  repeated cosmos.base.v1beta1.Coin balances = 1
      [(gogoproto.nullable) = false, (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];

  // pagination defines the pagination in the response.
  cosmos.base.query.v1beta1.PageResponse pagination = 2;
}
```

`0.40` comes with an efficient querier pagination, it now uses `Prefix` stores to query. 
There are 2 helpers for `pagination`, 1) `Paginate` 2) `FilteredPaginate`.

### Client
- `context.CLIContext` is renamed to `client.Context` and moved to `github.com/cosmos/cosmos-sdk/client`
- The global `viper` usage is removed from client and is replaced with Cobra' `cmd.Flags()`. There are two helpers 
to read common flags for CLI txs and queries. 
```go
clientCtx, err := client.ReadTxCommandFlags(clientCtx, cmd.Flags())
clientCtx, err := client.ReadQueryCommandFlags(clientCtx, cmd.Flags())
```
- Flags helper functions `flags.PostCommands(cmds ...*cobra.Command) []*cobra.Command`, `flags.GetCommands(...)` usage
 is now replaced by `flags.AddTxFlagsToCmd(cmd *cobra.Command)` and `flags.AddQueryFlagsToCmd(cmd *cobra.Command)` 
 respectively. 
- New CLI tx commands doesn't take `codec` as an input now. 
```go
// v0.39.x
func SendTxCmd(cdc *codec.Codec) *cobra.Command {
	...
}

// v0.40
func NewSendTxCmd() *cobra.Command {
	...
}
```
*Sample code for new tx command:*
```go
// NewSendTxCmd returns a CLI command handler for creating a MsgSend transaction.
func NewSendTxCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use: "send [from_key_or_address] [to_address] [amount]",
		Short: `Send funds from one account to another. Note, the'--from' flag is
ignored as it is implied from [from_key_or_address].`,
		Args: cobra.ExactArgs(3),
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.Flags().Set(flags.FlagFrom, args[0])

			clientCtx := client.GetClientContextFromCmd(cmd)
			clientCtx, err := client.ReadTxCommandFlags(clientCtx, cmd.Flags())
			if err != nil {
				return err
			}

			toAddr, err := sdk.AccAddressFromBech32(args[1])
			if err != nil {
				return err
			}

			coins, err := sdk.ParseCoins(args[2])
			if err != nil {
				return err
			}

			msg := types.NewMsgSend(clientCtx.GetFromAddress(), toAddr, coins)
			if err := msg.ValidateBasic(); err != nil {
				return err
			}

			return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)
		},
	}

	flags.AddTxFlagsToCmd(cmd)

	return cmd
}
```

## Updating a cosmos-sdk chain to use SDK 0.40
This section covers the changes to `BaseApp` and related changes in `app.go`, `config`
#### BaseApp
`BaseApp` now has two new fields, `GRPCQueryRouter` and `MsgServiceRouter`
- `GRPCQueryRouter` routes ABCI Query requests to GRPC handlers.
- `GRPCQueryHandler` defines a function type which handles ABCI Query requests using gRPC

- [TODO] explain `baseapp/grpcrouter.go` 
- [TODO] explain `app.go` updates
- [TODO] explain `server` updates

#### REST Queries and Swagger Generation
[grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway) is a project that translates REST calls into GRPC calls 
using special annotations on service methods. Modules that want to expose REST queries should add 
`google.api.http` annotations to their `rpc` methods


## Upgrading a live chain to v0.40

There are two ways to upgrade a chain from `0.39` to `0.40`,
- Using manual `state export`. `migrate` and `upgrade`
- Using `upgradeHandler` from `x/upgrade`

### Risks
As a validator performing the upgrade procedure on your consensus nodes carries a heightened risk of double-signing and
being slashed. The most important piece of this procedure is verifying your software version and genesis file hash before
starting your validator and signing.

The riskiest thing a validator can do is discover that they made a mistake and repeat the upgrade procedure again during
the network startup. If you discover a mistake in the process, the best thing to do is wait for the network to start
before correcting it. If the network is halted and you have started with a different genesis file than the expected one,
seek advice from the validator community.

### Recovery
* Prior to exporting the state, the validators are encouraged to take a full data snapshot at exported height. Exported
height will be determined by a governance proposal. Data backup is usually done by copying daemon home directory,
ex: `~/.gaiad`

It is critically important to back-up the validator state file, ex: `~/.gaiad/data/priv_validator_state.json` file
after stopping your daemon process. This file is updated every block as your validator participates in a consensus
rounds. It is a critical file needed to prevent double-signing, in case the upgrade fails and the previous chain needs
to be restarted.

In the event that the upgrade does not succeed, validators and operators must downgrade back to old version of the
software and restore to their latest snapshot before restarting their nodes.

### Upgrade procedure
- Use old binary to export the state. Make sure to verify your binary version before exporting the state
- Export the state from existing chain using old-binary (which uses `sdk@0.39.x`).
Example:
    ```sh
    gaiad export --for-zero-height --height <height> > 039_exported_state.json
    ```
- Verify the SHA256 of the (sorted) exported genesis file:
    ```shell
    $ jq -S -c -M '' 039_exported_state.json | shasum -a 256
    [PLACEHOLDER]  039_exported_state.json
    ```
- Cross check the hash with other peers (other validators) in the chat rooms
- Install the latest binary (which uses `0.40`)
- Migrate the exported state to `0.40` compatible genesis state
    ```shell
    gaiad migrate v40 039_exported_state.json --chain-id <new_chain_id> --genesis-time <new_genesis_time_in_utc> > new_v40_genesis.json
    ```
  NOTE: The migrate command takes an input genesis state and migrates it to a targeted version. New `genesis-time` will
  be as mentioned in the governance proposal.
- Verify the SHA256 of the migrated genesis file with other valdiators to make sure there are no manual errors in the process.
    ```shell
    $ jq -S -c -M '' new_v40_genesis.json | shasum -a 256
    [PLACEHOLDER]  new_v40_genesis.json
    ```
- Make sure to update the genesis parameters in the new genesis if any. All these details will be generally present in
the governance proposal
- All the necessary state chanegs are handled in `040` migration command, including tendermint params. So, manual updates to
the genesis are not required
- Reset the old state
NOTE: Be sure you have a complete backed up state of your node before proceeding with this step.
See Recovery for details on how to proceed.
```shell
gaiad unsafe-reset-all
```
- Move the new genesis.json to your daemon config directory. Ex
```shell script
cp new_v40_genesis.json ~/.gaiad/config/genesis.json
```

- Update `~/.gaiad/config/app.toml` to include latest app configurations. Below is an example `app.toml`. Make sure to
update your custom configurations as per your validator design ex: `gas_price`.

```yaml
# This is a TOML config file.
# For more information, see https://github.com/toml-lang/toml
###############################################################################
###                           Base Configuration                            ###
###############################################################################
# The minimum gas prices a validator is willing to accept for processing a
# transaction. A transaction's fees must meet the minimum of any denomination
# specified in this config (e.g. 0.25token1;0.0001token2).
minimum-gas-prices = ""
# default: the last 100 states are kept in addition to every 500th state; pruning at 10 block intervals
# nothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)
# everything: all saved states will be deleted, storing only the current state; pruning at 10 block intervals
# custom: allow pruning options to be manually specified through 'pruning-keep-recent', 'pruning-keep-every', and 'pruning-interval'
pruning = "default"
# These are applied if and only if the pruning strategy is custom.
pruning-keep-recent = "0"
pruning-keep-every = "0"
pruning-interval = "0"
# HaltHeight contains a non-zero block height at which a node will gracefully
# halt and shutdown that can be used to assist upgrades and testing.
#
# Note: Commitment of state will be attempted on the corresponding block.
halt-height = 0
# HaltTime contains a non-zero minimum block time (in Unix seconds) at which
# a node will gracefully halt and shutdown that can be used to assist upgrades
# and testing.
#
# Note: Commitment of state will be attempted on the corresponding block.
halt-time = 0
# MinRetainBlocks defines the minimum block height offset from the current
# block being committed, such that all blocks past this offset are pruned
# from Tendermint. It is used as part of the process of determining the
# ResponseCommit.RetainHeight value during ABCI Commit. A value of 0 indicates
# that no blocks should be pruned.
#
# This configuration value is only responsible for pruning Tendermint blocks.
# It has no bearing on application state pruning which is determined by the
# "pruning-*" configurations.
#
# Note: Tendermint block pruning is dependant on this parameter in conunction
# with the unbonding (safety threshold) period, state pruning and state sync
# snapshot parameters to determine the correct minimum value of
# ResponseCommit.RetainHeight.
min-retain-blocks = 0
# InterBlockCache enables inter-block caching.
inter-block-cache = true
# IndexEvents defines the set of events in the form {eventType}.{attributeKey},
# which informs Tendermint what to index. If empty, all events will be indexed.
#
# Example:
# ["message.sender", "message.recipient"]
index-events = []
###############################################################################
###                         Telemetry Configuration                         ###
###############################################################################
[telemetry]
# Prefixed with keys to separate services.
service-name = ""
# Enabled enables the application telemetry functionality. When enabled,
# an in-memory sink is also enabled by default. Operators may also enabled
# other sinks such as Prometheus.
enabled = false
# Enable prefixing gauge values with hostname.
enable-hostname = false
# Enable adding hostname to labels.
enable-hostname-label = false
# Enable adding service to labels.
enable-service-label = false
# PrometheusRetentionTime, when positive, enables a Prometheus metrics sink.
prometheus-retention-time = 0
# GlobalLabels defines a global set of name/value label tuples applied to all
# metrics emitted using the wrapper functions defined in telemetry package.
#
# Example:
# [["chain_id", "cosmoshub-1"]]
global-labels = [
]
###############################################################################
###                           API Configuration                             ###
###############################################################################
[api]
# Enable defines if the API server should be enabled.
enable = false
# Swagger defines if swagger documentation should automatically be registered.
swagger = false
# Address defines the API server to listen on.
address = "tcp://0.0.0.0:1317"
# MaxOpenConnections defines the number of maximum open connections.
max-open-connections = 1000
# RPCReadTimeout defines the Tendermint RPC read timeout (in seconds).
rpc-read-timeout = 10
# RPCWriteTimeout defines the Tendermint RPC write timeout (in seconds).
rpc-write-timeout = 0
# RPCMaxBodyBytes defines the Tendermint maximum response body (in bytes).
rpc-max-body-bytes = 1000000
# EnableUnsafeCORS defines if CORS should be enabled (unsafe - use it at your own risk).
enabled-unsafe-cors = false
###############################################################################
###                           gRPC Configuration                            ###
###############################################################################
[grpc]
# Enable defines if the gRPC server should be enabled.
enable = true
# Address defines the gRPC server address to bind to.
address = "0.0.0.0:9090"
###############################################################################
###                        State Sync Configuration                         ###
###############################################################################
# State sync snapshots allow other nodes to rapidly join the network without replaying historical
# blocks, instead downloading and applying a snapshot of the application state at a given height.
[state-sync]
# snapshot-interval specifies the block interval at which local state sync snapshots are
# taken (0 to disable). Must be a multiple of pruning-keep-every.
snapshot-interval = 0
# snapshot-keep-recent specifies the number of recent snapshots to keep and serve (0 to keep all).
snapshot-keep-recent = 2
```

The updates to `app.toml` are:
- API is now configured to run in-process with daemon, previously it was a separate process, invoked by running rest-server
command i.e., `gaiacli rest-server`. Now it is in-process with daemon and can be enabled/disabled by API configuration:
```yaml
[api]
# Enable defines if the API server should be enabled.
enable = false
# Swagger defines if swagger documentation should automatically be registered.
swagger = false
```
`swagger` setting refers to enabling/disabling swagger docs API, i.e, `/swagger/` API endpoint.

- gRPC Configuration
```yaml
[grpc]
# Enable defines if the gRPC server should be enabled.
enable = true
# Address defines the gRPC server address to bind to.
address = "0.0.0.0:9090"
```

- State Sync Configuration
```yaml
# State sync snapshots allow other nodes to rapidly join the network without replaying historical
# blocks, instead downloading and applying a snapshot of the application state at a given height.
[state-sync]
# snapshot-interval specifies the block interval at which local state sync snapshots are
# taken (0 to disable). Must be a multiple of pruning-keep-every.
snapshot-interval = 0
# snapshot-keep-recent specifies the number of recent snapshots to keep and serve (0 to keep all).
snapshot-keep-recent = 2
```

- Kill if any external `rest-server` process is running

- All set now! You can (re)start your daemon to validate on the upgraded network. Make sure to check your binary version
before starting the daemon. Ex:

```
gaiad version --long
```

References:
- [ADR 019 - Protobuf State Encoding](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-019-protobuf-state-encoding.md)
- [ADR 020 - Protobuf Transaction Encoding](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-020-protobuf-transaction-encoding.md)
- [ADR 021 - Protobuf Query Encoding](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-021-protobuf-query-encoding.md)
- [ADR 023 - Protobuf Naming](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-023-protobuf-naming.md)
- [ADR 031 - Protobuf Msg Services](https://github.com/cosmos/cosmos-sdk/blob/master/docs/architecture/adr-031-msg-service.md)